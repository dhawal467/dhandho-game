import {
  lookup
} from "./chunk-C3H3EJGW.js";
import {
  CreateGameReducer,
  InitializeGame,
  IsLongFormMove,
  MAKE_MOVE,
  PlayerView,
  ProcessGameConfig,
  REDO,
  TransientHandlingMiddleware,
  Transport,
  UNDO,
  applyMiddleware,
  createStore,
  error,
  require_rfc6902
} from "./chunk-3E4GEX53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/boardgame.io/dist/esm/util-991e76bb.js
var Type;
(function(Type2) {
  Type2[Type2["SYNC"] = 0] = "SYNC";
  Type2[Type2["ASYNC"] = 1] = "ASYNC";
})(Type || (Type = {}));
function isSynchronous(storageAPI) {
  return storageAPI.type() === Type.SYNC;
}
var Sync = class {
  type() {
    return Type.SYNC;
  }
  /**
   * Connect.
   */
  connect() {
    return;
  }
  /**
   * Create a new match.
   *
   * This might just need to call setState and setMetadata in
   * most implementations.
   *
   * However, it exists as a separate call so that the
   * implementation can provision things differently when
   * a match is created.  For example, it might stow away the
   * initial match state in a separate field for easier retrieval.
   */
  /* istanbul ignore next */
  createMatch(matchID, opts) {
    if (this.createGame) {
      console.warn("The database connector does not implement a createMatch method.", "\nUsing the deprecated createGame method instead.");
      return this.createGame(matchID, opts);
    } else {
      console.error("The database connector does not implement a createMatch method.");
    }
  }
  /**
   * Return all matches.
   */
  /* istanbul ignore next */
  listMatches(opts) {
    if (this.listGames) {
      console.warn("The database connector does not implement a listMatches method.", "\nUsing the deprecated listGames method instead.");
      return this.listGames(opts);
    } else {
      console.error("The database connector does not implement a listMatches method.");
    }
  }
};
var createMetadata = ({ game, unlisted, setupData, numPlayers }) => {
  const metadata = {
    gameName: game.name,
    unlisted: !!unlisted,
    players: {},
    createdAt: Date.now(),
    updatedAt: Date.now()
  };
  if (setupData !== void 0)
    metadata.setupData = setupData;
  for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
    metadata.players[playerIndex] = { id: playerIndex };
  }
  return metadata;
};
var createMatch = ({ game, numPlayers, setupData, unlisted }) => {
  if (!numPlayers || typeof numPlayers !== "number")
    numPlayers = 2;
  const setupDataError = game.validateSetupData && game.validateSetupData(setupData, numPlayers);
  if (setupDataError !== void 0)
    return { setupDataError };
  const metadata = createMetadata({ game, numPlayers, setupData, unlisted });
  const initialState = InitializeGame({ game, numPlayers, setupData });
  return { metadata, initialState };
};

// node_modules/boardgame.io/dist/esm/master-17425f07.js
var filterMatchData = (matchData) => Object.values(matchData.players).map((player) => {
  const { credentials, ...filteredData } = player;
  return filteredData;
});
var stripCredentialsFromAction = (action) => {
  const { credentials, ...payload } = action.payload;
  return { ...action, payload };
};
var Master = class {
  constructor(game, storageAPI, transportAPI, auth) {
    this.game = ProcessGameConfig(game);
    this.storageAPI = storageAPI;
    this.transportAPI = transportAPI;
    this.subscribeCallback = () => {
    };
    this.auth = auth;
  }
  subscribe(fn) {
    this.subscribeCallback = fn;
  }
  /**
   * Called on each move / event made by the client.
   * Computes the new value of the game state and returns it
   * along with a deltalog.
   */
  async onUpdate(credAction, stateID, matchID, playerID) {
    if (!credAction || !credAction.payload) {
      return { error: "missing action or action payload" };
    }
    let metadata;
    if (isSynchronous(this.storageAPI)) {
      ({ metadata } = this.storageAPI.fetch(matchID, { metadata: true }));
    } else {
      ({ metadata } = await this.storageAPI.fetch(matchID, { metadata: true }));
    }
    if (this.auth) {
      const isAuthentic = await this.auth.authenticateCredentials({
        playerID,
        credentials: credAction.payload.credentials,
        metadata
      });
      if (!isAuthentic) {
        return { error: "unauthorized action" };
      }
    }
    const action = stripCredentialsFromAction(credAction);
    const key = matchID;
    let state;
    if (isSynchronous(this.storageAPI)) {
      ({ state } = this.storageAPI.fetch(key, { state: true }));
    } else {
      ({ state } = await this.storageAPI.fetch(key, { state: true }));
    }
    if (state === void 0) {
      error(`game not found, matchID=[${key}]`);
      return { error: "game not found" };
    }
    if (state.ctx.gameover !== void 0) {
      error(`game over - matchID=[${key}] - playerID=[${playerID}] - action[${action.payload.type}]`);
      return;
    }
    const reducer = CreateGameReducer({
      game: this.game
    });
    const middleware = applyMiddleware(TransientHandlingMiddleware);
    const store = createStore(reducer, state, middleware);
    if (action.type == UNDO || action.type == REDO) {
      const hasActivePlayers = state.ctx.activePlayers !== null;
      const isCurrentPlayer = state.ctx.currentPlayer === playerID;
      if (
        // If activePlayers is empty, non-current players can’t undo.
        !hasActivePlayers && !isCurrentPlayer || // If player is not active or multiple players are active, can’t undo.
        hasActivePlayers && (state.ctx.activePlayers[playerID] === void 0 || Object.keys(state.ctx.activePlayers).length > 1)
      ) {
        error(`playerID=[${playerID}] cannot undo / redo right now`);
        return;
      }
    }
    if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {
      error(`player not active - playerID=[${playerID}] - action[${action.payload.type}]`);
      return;
    }
    const move = action.type == MAKE_MOVE ? this.game.flow.getMove(state.ctx, action.payload.type, playerID) : null;
    if (action.type == MAKE_MOVE && !move) {
      error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}] - action[${action.payload.type}]`);
      return;
    }
    if (state._stateID !== stateID && !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {
      error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}] - playerID=[${playerID}] - action[${action.payload.type}]`);
      return;
    }
    const prevState = store.getState();
    store.dispatch(action);
    state = store.getState();
    this.subscribeCallback({
      state,
      action,
      matchID
    });
    if (this.game.deltaState) {
      this.transportAPI.sendAll({
        type: "patch",
        args: [matchID, stateID, prevState, state]
      });
    } else {
      this.transportAPI.sendAll({
        type: "update",
        args: [matchID, state]
      });
    }
    const { deltalog, ...stateWithoutDeltalog } = state;
    let newMetadata;
    if (metadata && (metadata.gameover === void 0 || metadata.gameover === null)) {
      newMetadata = {
        ...metadata,
        updatedAt: Date.now()
      };
      if (state.ctx.gameover !== void 0) {
        newMetadata.gameover = state.ctx.gameover;
      }
    }
    if (isSynchronous(this.storageAPI)) {
      this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);
      if (newMetadata)
        this.storageAPI.setMetadata(key, newMetadata);
    } else {
      const writes = [
        this.storageAPI.setState(key, stateWithoutDeltalog, deltalog)
      ];
      if (newMetadata) {
        writes.push(this.storageAPI.setMetadata(key, newMetadata));
      }
      await Promise.all(writes);
    }
  }
  /**
   * Called when the client connects / reconnects.
   * Returns the latest game state and the entire log.
   */
  async onSync(matchID, playerID, credentials, numPlayers = 2) {
    const key = matchID;
    const fetchOpts = {
      state: true,
      metadata: true,
      log: true,
      initialState: true
    };
    const fetchResult = isSynchronous(this.storageAPI) ? this.storageAPI.fetch(key, fetchOpts) : await this.storageAPI.fetch(key, fetchOpts);
    let { state, initialState, log, metadata } = fetchResult;
    if (this.auth && playerID !== void 0 && playerID !== null) {
      const isAuthentic = await this.auth.authenticateCredentials({
        playerID,
        credentials,
        metadata
      });
      if (!isAuthentic) {
        return { error: "unauthorized" };
      }
    }
    if (state === void 0) {
      const match = createMatch({
        game: this.game,
        unlisted: true,
        numPlayers,
        setupData: void 0
      });
      if ("setupDataError" in match) {
        return { error: "game requires setupData" };
      }
      initialState = state = match.initialState;
      metadata = match.metadata;
      this.subscribeCallback({ state, matchID });
      if (isSynchronous(this.storageAPI)) {
        this.storageAPI.createMatch(key, { initialState, metadata });
      } else {
        await this.storageAPI.createMatch(key, { initialState, metadata });
      }
    }
    const filteredMetadata = metadata ? filterMatchData(metadata) : void 0;
    const syncInfo = {
      state,
      log,
      filteredMetadata,
      initialState
    };
    this.transportAPI.send({
      playerID,
      type: "sync",
      args: [matchID, syncInfo]
    });
    return;
  }
  /**
   * Called when a client connects or disconnects.
   * Updates and sends out metadata to reflect the player’s connection status.
   */
  async onConnectionChange(matchID, playerID, credentials, connected) {
    const key = matchID;
    if (playerID === void 0 || playerID === null) {
      return;
    }
    let metadata;
    if (isSynchronous(this.storageAPI)) {
      ({ metadata } = this.storageAPI.fetch(key, { metadata: true }));
    } else {
      ({ metadata } = await this.storageAPI.fetch(key, { metadata: true }));
    }
    if (metadata === void 0) {
      error(`metadata not found for matchID=[${key}]`);
      return { error: "metadata not found" };
    }
    if (metadata.players[playerID] === void 0) {
      error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);
      return { error: "player not in the match" };
    }
    if (this.auth) {
      const isAuthentic = await this.auth.authenticateCredentials({
        playerID,
        credentials,
        metadata
      });
      if (!isAuthentic) {
        return { error: "unauthorized" };
      }
    }
    metadata.players[playerID].isConnected = connected;
    const filteredMetadata = filterMatchData(metadata);
    this.transportAPI.sendAll({
      type: "matchData",
      args: [matchID, filteredMetadata]
    });
    if (isSynchronous(this.storageAPI)) {
      this.storageAPI.setMetadata(key, metadata);
    } else {
      await this.storageAPI.setMetadata(key, metadata);
    }
  }
  async onChatMessage(matchID, chatMessage, credentials) {
    const key = matchID;
    if (this.auth) {
      const { metadata } = await this.storageAPI.fetch(key, {
        metadata: true
      });
      if (!(chatMessage && typeof chatMessage.sender === "string")) {
        return { error: "unauthorized" };
      }
      const isAuthentic = await this.auth.authenticateCredentials({
        playerID: chatMessage.sender,
        credentials,
        metadata
      });
      if (!isAuthentic) {
        return { error: "unauthorized" };
      }
    }
    this.transportAPI.sendAll({
      type: "chat",
      args: [matchID, chatMessage]
    });
  }
};

// node_modules/boardgame.io/dist/esm/filter-player-view-43ed49b0.js
var import_rfc6902 = __toESM(require_rfc6902());
var applyPlayerView = (game, playerID, state) => ({
  ...state,
  G: game.playerView({ G: state.G, ctx: state.ctx, playerID }),
  plugins: PlayerView(state, { playerID, game }),
  deltalog: void 0,
  _undo: [],
  _redo: []
});
var getFilterPlayerView = (game) => (playerID, payload) => {
  switch (payload.type) {
    case "patch": {
      const [matchID, stateID, prevState, state] = payload.args;
      const log = redactLog(state.deltalog, playerID);
      const filteredState = applyPlayerView(game, playerID, state);
      const newStateID = state._stateID;
      const prevFilteredState = applyPlayerView(game, playerID, prevState);
      const patch = (0, import_rfc6902.createPatch)(prevFilteredState, filteredState);
      return {
        type: "patch",
        args: [matchID, stateID, newStateID, patch, log]
      };
    }
    case "update": {
      const [matchID, state] = payload.args;
      const log = redactLog(state.deltalog, playerID);
      const filteredState = applyPlayerView(game, playerID, state);
      return {
        type: "update",
        args: [matchID, filteredState, log]
      };
    }
    case "sync": {
      const [matchID, syncInfo] = payload.args;
      const filteredState = applyPlayerView(game, playerID, syncInfo.state);
      const log = redactLog(syncInfo.log, playerID);
      const newSyncInfo = {
        ...syncInfo,
        state: filteredState,
        log
      };
      return {
        type: "sync",
        args: [matchID, newSyncInfo]
      };
    }
    default: {
      return payload;
    }
  }
};
function redactLog(log, playerID) {
  if (log === void 0) {
    return log;
  }
  return log.map((logEvent) => {
    if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {
      return logEvent;
    }
    if (logEvent.redact !== true) {
      return logEvent;
    }
    const payload = {
      ...logEvent.action.payload,
      args: null
    };
    const filteredEvent = {
      ...logEvent,
      action: { ...logEvent.action, payload }
    };
    const { redact, ...remaining } = filteredEvent;
    return remaining;
  });
}

// node_modules/boardgame.io/dist/esm/socketio-a82b84e4.js
var InMemory = class extends Sync {
  /**
   * Creates a new InMemory storage.
   */
  constructor() {
    super();
    this.state = /* @__PURE__ */ new Map();
    this.initial = /* @__PURE__ */ new Map();
    this.metadata = /* @__PURE__ */ new Map();
    this.log = /* @__PURE__ */ new Map();
  }
  /**
   * Create a new match.
   *
   * @override
   */
  createMatch(matchID, opts) {
    this.initial.set(matchID, opts.initialState);
    this.setState(matchID, opts.initialState);
    this.setMetadata(matchID, opts.metadata);
  }
  /**
   * Write the match metadata to the in-memory object.
   */
  setMetadata(matchID, metadata) {
    this.metadata.set(matchID, metadata);
  }
  /**
   * Write the match state to the in-memory object.
   */
  setState(matchID, state, deltalog) {
    if (deltalog && deltalog.length > 0) {
      const log = this.log.get(matchID) || [];
      this.log.set(matchID, [...log, ...deltalog]);
    }
    this.state.set(matchID, state);
  }
  /**
   * Fetches state for a particular matchID.
   */
  fetch(matchID, opts) {
    const result = {};
    if (opts.state) {
      result.state = this.state.get(matchID);
    }
    if (opts.metadata) {
      result.metadata = this.metadata.get(matchID);
    }
    if (opts.log) {
      result.log = this.log.get(matchID) || [];
    }
    if (opts.initialState) {
      result.initialState = this.initial.get(matchID);
    }
    return result;
  }
  /**
   * Remove the match state from the in-memory object.
   */
  wipe(matchID) {
    this.state.delete(matchID);
    this.metadata.delete(matchID);
  }
  /**
   * Return all keys.
   *
   * @override
   */
  listMatches(opts) {
    return [...this.metadata.entries()].filter(([, metadata]) => {
      if (!opts) {
        return true;
      }
      if (opts.gameName !== void 0 && metadata.gameName !== opts.gameName) {
        return false;
      }
      if (opts.where !== void 0) {
        if (opts.where.isGameover !== void 0) {
          const isGameover = metadata.gameover !== void 0;
          if (isGameover !== opts.where.isGameover) {
            return false;
          }
        }
        if (opts.where.updatedBefore !== void 0 && metadata.updatedAt >= opts.where.updatedBefore) {
          return false;
        }
        if (opts.where.updatedAfter !== void 0 && metadata.updatedAt <= opts.where.updatedAfter) {
          return false;
        }
      }
      return true;
    }).map(([key]) => key);
  }
};
var WithLocalStorageMap = class extends Map {
  constructor(key) {
    super();
    this.key = key;
    const cache = JSON.parse(localStorage.getItem(this.key)) || [];
    cache.forEach((entry) => this.set(...entry));
  }
  sync() {
    const entries = [...this.entries()];
    localStorage.setItem(this.key, JSON.stringify(entries));
  }
  set(key, value) {
    super.set(key, value);
    this.sync();
    return this;
  }
  delete(key) {
    const result = super.delete(key);
    this.sync();
    return result;
  }
};
var LocalStorage = class extends InMemory {
  constructor(storagePrefix = "bgio") {
    super();
    const StorageMap = (stateKey) => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);
    this.state = StorageMap("state");
    this.initial = StorageMap("initial");
    this.metadata = StorageMap("metadata");
    this.log = StorageMap("log");
  }
};
function GetBotPlayer(state, bots) {
  if (state.ctx.gameover !== void 0) {
    return null;
  }
  if (state.ctx.activePlayers) {
    for (const key of Object.keys(bots)) {
      if (key in state.ctx.activePlayers) {
        return key;
      }
    }
  } else if (state.ctx.currentPlayer in bots) {
    return state.ctx.currentPlayer;
  }
  return null;
}
var LocalMaster = class extends Master {
  constructor({ game, bots, storageKey, persist }) {
    const clientCallbacks = {};
    const initializedBots = {};
    if (game && game.ai && bots) {
      for (const playerID in bots) {
        const bot = bots[playerID];
        initializedBots[playerID] = new bot({
          game,
          enumerate: game.ai.enumerate,
          seed: game.seed
        });
      }
    }
    const send = ({ playerID, ...data }) => {
      const callback = clientCallbacks[playerID];
      if (callback !== void 0) {
        callback(filterPlayerView(playerID, data));
      }
    };
    const filterPlayerView = getFilterPlayerView(game);
    const transportAPI = {
      send,
      sendAll: (payload) => {
        for (const playerID in clientCallbacks) {
          send({ playerID, ...payload });
        }
      }
    };
    const storage = persist ? new LocalStorage(storageKey) : new InMemory();
    super(game, storage, transportAPI);
    this.connect = (playerID, callback) => {
      clientCallbacks[playerID] = callback;
    };
    this.subscribe(({ state, matchID }) => {
      if (!bots) {
        return;
      }
      const botPlayer = GetBotPlayer(state, initializedBots);
      if (botPlayer !== null) {
        setTimeout(async () => {
          const botAction = await initializedBots[botPlayer].play(state, botPlayer);
          await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);
        }, 100);
      }
    });
  }
};
var LocalTransport = class extends Transport {
  /**
   * Creates a new Mutiplayer instance.
   * @param {string} matchID - The game ID to connect to.
   * @param {string} playerID - The player ID associated with this client.
   * @param {string} gameName - The game type (the `name` field in `Game`).
   * @param {string} numPlayers - The number of players.
   */
  constructor({ master, ...opts }) {
    super(opts);
    this.master = master;
  }
  sendChatMessage(matchID, chatMessage) {
    const args = [
      matchID,
      chatMessage,
      this.credentials
    ];
    this.master.onChatMessage(...args);
  }
  sendAction(state, action) {
    this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);
  }
  requestSync() {
    this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);
  }
  connect() {
    this.setConnectionStatus(true);
    this.master.connect(this.playerID, (data) => this.notifyClient(data));
    this.requestSync();
  }
  disconnect() {
    this.setConnectionStatus(false);
  }
  updateMatchID(id) {
    this.matchID = id;
    this.connect();
  }
  updatePlayerID(id) {
    this.playerID = id;
    this.connect();
  }
  updateCredentials(credentials) {
    this.credentials = credentials;
    this.connect();
  }
};
var localMasters = /* @__PURE__ */ new Map();
function Local({ bots, persist, storageKey } = {}) {
  return (transportOpts) => {
    const { gameKey, game } = transportOpts;
    let master;
    const instance = localMasters.get(gameKey);
    if (instance && instance.bots === bots && instance.storageKey === storageKey && instance.persist === persist) {
      master = instance.master;
    }
    if (!master) {
      master = new LocalMaster({ game, bots, persist, storageKey });
      localMasters.set(gameKey, { master, bots, persist, storageKey });
    }
    return new LocalTransport({ master, ...transportOpts });
  };
}
var io = lookup;
var SocketIOTransport = class extends Transport {
  /**
   * Creates a new Multiplayer instance.
   * @param {object} socket - Override for unit tests.
   * @param {object} socketOpts - Options to pass to socket.io.
   * @param {object} store - Redux store
   * @param {string} matchID - The game ID to connect to.
   * @param {string} playerID - The player ID associated with this client.
   * @param {string} credentials - Authentication credentials
   * @param {string} gameName - The game type (the `name` field in `Game`).
   * @param {string} numPlayers - The number of players.
   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.
   */
  constructor({ socket, socketOpts, server, ...opts }) {
    super(opts);
    this.server = server;
    this.socket = socket;
    this.socketOpts = socketOpts;
  }
  sendAction(state, action) {
    const args = [
      action,
      state._stateID,
      this.matchID,
      this.playerID
    ];
    this.socket.emit("update", ...args);
  }
  sendChatMessage(matchID, chatMessage) {
    const args = [
      matchID,
      chatMessage,
      this.credentials
    ];
    this.socket.emit("chat", ...args);
  }
  connect() {
    if (!this.socket) {
      if (this.server) {
        let server = this.server;
        if (server.search(/^https?:\/\//) == -1) {
          server = "http://" + this.server;
        }
        if (server.slice(-1) != "/") {
          server = server + "/";
        }
        this.socket = io(server + this.gameName, this.socketOpts);
      } else {
        this.socket = io("/" + this.gameName, this.socketOpts);
      }
    }
    this.socket.on("patch", (matchID, prevStateID, stateID, patch, deltalog) => {
      this.notifyClient({
        type: "patch",
        args: [matchID, prevStateID, stateID, patch, deltalog]
      });
    });
    this.socket.on("update", (matchID, state, deltalog) => {
      this.notifyClient({
        type: "update",
        args: [matchID, state, deltalog]
      });
    });
    this.socket.on("sync", (matchID, syncInfo) => {
      this.notifyClient({ type: "sync", args: [matchID, syncInfo] });
    });
    this.socket.on("matchData", (matchID, matchData) => {
      this.notifyClient({ type: "matchData", args: [matchID, matchData] });
    });
    this.socket.on("chat", (matchID, chatMessage) => {
      this.notifyClient({ type: "chat", args: [matchID, chatMessage] });
    });
    this.socket.on("connect", () => {
      this.requestSync();
      this.setConnectionStatus(true);
    });
    this.socket.on("disconnect", () => {
      this.setConnectionStatus(false);
    });
  }
  disconnect() {
    this.socket.close();
    this.socket = null;
    this.setConnectionStatus(false);
  }
  requestSync() {
    if (this.socket) {
      const args = [
        this.matchID,
        this.playerID,
        this.credentials,
        this.numPlayers
      ];
      this.socket.emit("sync", ...args);
    }
  }
  updateMatchID(id) {
    this.matchID = id;
    this.requestSync();
  }
  updatePlayerID(id) {
    this.playerID = id;
    this.requestSync();
  }
  updateCredentials(credentials) {
    this.credentials = credentials;
    this.requestSync();
  }
};
function SocketIO({ server, socketOpts } = {}) {
  return (transportOpts) => new SocketIOTransport({
    server,
    socketOpts,
    ...transportOpts
  });
}

export {
  Local,
  SocketIO
};
//# sourceMappingURL=chunk-F3Q2AL2U.js.map
