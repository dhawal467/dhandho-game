{
  "version": 3,
  "sources": ["../../boardgame.io/dist/esm/util-991e76bb.js", "../../boardgame.io/dist/esm/master-17425f07.js", "../../boardgame.io/dist/esm/filter-player-view-43ed49b0.js", "../../boardgame.io/dist/esm/socketio-a82b84e4.js"],
  "sourcesContent": ["import { I as InitializeGame } from './initialize-7316768f.js';\n\nvar Type;\r\n(function (Type) {\r\n    Type[Type[\"SYNC\"] = 0] = \"SYNC\";\r\n    Type[Type[\"ASYNC\"] = 1] = \"ASYNC\";\r\n})(Type || (Type = {}));\r\n/**\r\n * Type guard that checks if a storage implementation is synchronous.\r\n */\r\nfunction isSynchronous(storageAPI) {\r\n    return storageAPI.type() === Type.SYNC;\r\n}\r\nclass Async {\r\n    /* istanbul ignore next */\r\n    type() {\r\n        /* istanbul ignore next */\r\n        return Type.ASYNC;\r\n    }\r\n    /**\r\n     * Create a new match.\r\n     *\r\n     * This might just need to call setState and setMetadata in\r\n     * most implementations.\r\n     *\r\n     * However, it exists as a separate call so that the\r\n     * implementation can provision things differently when\r\n     * a match is created.  For example, it might stow away the\r\n     * initial match state in a separate field for easier retrieval.\r\n     */\r\n    /* istanbul ignore next */\r\n    async createMatch(matchID, opts) {\r\n        if (this.createGame) {\r\n            console.warn('The database connector does not implement a createMatch method.', '\\nUsing the deprecated createGame method instead.');\r\n            return this.createGame(matchID, opts);\r\n        }\r\n        else {\r\n            console.error('The database connector does not implement a createMatch method.');\r\n        }\r\n    }\r\n    /**\r\n     * Return all matches.\r\n     */\r\n    /* istanbul ignore next */\r\n    async listMatches(opts) {\r\n        if (this.listGames) {\r\n            console.warn('The database connector does not implement a listMatches method.', '\\nUsing the deprecated listGames method instead.');\r\n            return this.listGames(opts);\r\n        }\r\n        else {\r\n            console.error('The database connector does not implement a listMatches method.');\r\n        }\r\n    }\r\n}\r\nclass Sync {\r\n    type() {\r\n        return Type.SYNC;\r\n    }\r\n    /**\r\n     * Connect.\r\n     */\r\n    connect() {\r\n        return;\r\n    }\r\n    /**\r\n     * Create a new match.\r\n     *\r\n     * This might just need to call setState and setMetadata in\r\n     * most implementations.\r\n     *\r\n     * However, it exists as a separate call so that the\r\n     * implementation can provision things differently when\r\n     * a match is created.  For example, it might stow away the\r\n     * initial match state in a separate field for easier retrieval.\r\n     */\r\n    /* istanbul ignore next */\r\n    createMatch(matchID, opts) {\r\n        if (this.createGame) {\r\n            console.warn('The database connector does not implement a createMatch method.', '\\nUsing the deprecated createGame method instead.');\r\n            return this.createGame(matchID, opts);\r\n        }\r\n        else {\r\n            console.error('The database connector does not implement a createMatch method.');\r\n        }\r\n    }\r\n    /**\r\n     * Return all matches.\r\n     */\r\n    /* istanbul ignore next */\r\n    listMatches(opts) {\r\n        if (this.listGames) {\r\n            console.warn('The database connector does not implement a listMatches method.', '\\nUsing the deprecated listGames method instead.');\r\n            return this.listGames(opts);\r\n        }\r\n        else {\r\n            console.error('The database connector does not implement a listMatches method.');\r\n        }\r\n    }\r\n}\n\n/**\r\n * Creates a new match metadata object.\r\n */\r\nconst createMetadata = ({ game, unlisted, setupData, numPlayers, }) => {\r\n    const metadata = {\r\n        gameName: game.name,\r\n        unlisted: !!unlisted,\r\n        players: {},\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n    };\r\n    if (setupData !== undefined)\r\n        metadata.setupData = setupData;\r\n    for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {\r\n        metadata.players[playerIndex] = { id: playerIndex };\r\n    }\r\n    return metadata;\r\n};\r\n/**\r\n * Creates initial state and metadata for a new match.\r\n * If the provided `setupData` doesn’t pass the game’s validation,\r\n * an error object is returned instead.\r\n */\r\nconst createMatch = ({ game, numPlayers, setupData, unlisted, }) => {\r\n    if (!numPlayers || typeof numPlayers !== 'number')\r\n        numPlayers = 2;\r\n    const setupDataError = game.validateSetupData && game.validateSetupData(setupData, numPlayers);\r\n    if (setupDataError !== undefined)\r\n        return { setupDataError };\r\n    const metadata = createMetadata({ game, numPlayers, setupData, unlisted });\r\n    const initialState = InitializeGame({ game, numPlayers, setupData });\r\n    return { metadata, initialState };\r\n};\n\nexport { Async as A, Sync as S, createMatch as c, isSynchronous as i };\n", "import { applyMiddleware, createStore } from 'redux';\nimport { e as error, j as UNDO, R as REDO, M as MAKE_MOVE } from './turn-order-8cc4909b.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-24ea3e4c.js';\nimport { i as isSynchronous, c as createMatch } from './util-991e76bb.js';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\r\nconst filterMatchData = (matchData) => Object.values(matchData.players).map((player) => {\r\n    const { credentials, ...filteredData } = player;\r\n    return filteredData;\r\n});\r\n/**\r\n * Remove player credentials from action payload\r\n */\r\nconst stripCredentialsFromAction = (action) => {\r\n    const { credentials, ...payload } = action.payload;\r\n    return { ...action, payload };\r\n};\r\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\r\nclass Master {\r\n    constructor(game, storageAPI, transportAPI, auth) {\r\n        this.game = ProcessGameConfig(game);\r\n        this.storageAPI = storageAPI;\r\n        this.transportAPI = transportAPI;\r\n        this.subscribeCallback = () => { };\r\n        this.auth = auth;\r\n    }\r\n    subscribe(fn) {\r\n        this.subscribeCallback = fn;\r\n    }\r\n    /**\r\n     * Called on each move / event made by the client.\r\n     * Computes the new value of the game state and returns it\r\n     * along with a deltalog.\r\n     */\r\n    async onUpdate(credAction, stateID, matchID, playerID) {\r\n        if (!credAction || !credAction.payload) {\r\n            return { error: 'missing action or action payload' };\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials: credAction.payload.credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized action' };\r\n            }\r\n        }\r\n        const action = stripCredentialsFromAction(credAction);\r\n        const key = matchID;\r\n        let state;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ state } = this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        else {\r\n            ({ state } = await this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        if (state === undefined) {\r\n            error(`game not found, matchID=[${key}]`);\r\n            return { error: 'game not found' };\r\n        }\r\n        if (state.ctx.gameover !== undefined) {\r\n            error(`game over - matchID=[${key}] - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const reducer = CreateGameReducer({\r\n            game: this.game,\r\n        });\r\n        const middleware = applyMiddleware(TransientHandlingMiddleware);\r\n        const store = createStore(reducer, state, middleware);\r\n        // Only allow UNDO / REDO if there is exactly one player\r\n        // that can make moves right now and the person doing the\r\n        // action is that player.\r\n        if (action.type == UNDO || action.type == REDO) {\r\n            const hasActivePlayers = state.ctx.activePlayers !== null;\r\n            const isCurrentPlayer = state.ctx.currentPlayer === playerID;\r\n            if (\r\n            // If activePlayers is empty, non-current players can’t undo.\r\n            (!hasActivePlayers && !isCurrentPlayer) ||\r\n                // If player is not active or multiple players are active, can’t undo.\r\n                (hasActivePlayers &&\r\n                    (state.ctx.activePlayers[playerID] === undefined ||\r\n                        Object.keys(state.ctx.activePlayers).length > 1))) {\r\n                error(`playerID=[${playerID}] cannot undo / redo right now`);\r\n                return;\r\n            }\r\n        }\r\n        // Check whether the player is active.\r\n        if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\r\n            error(`player not active - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Get move for further checks\r\n        const move = action.type == MAKE_MOVE\r\n            ? this.game.flow.getMove(state.ctx, action.payload.type, playerID)\r\n            : null;\r\n        // Check whether the player is allowed to make the move.\r\n        if (action.type == MAKE_MOVE && !move) {\r\n            error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Check if action's stateID is different than store's stateID\r\n        // and if move does not have ignoreStaleStateID truthy.\r\n        if (state._stateID !== stateID &&\r\n            !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\r\n            error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` +\r\n                ` - playerID=[${playerID}] - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const prevState = store.getState();\r\n        // Update server's version of the store.\r\n        store.dispatch(action);\r\n        state = store.getState();\r\n        this.subscribeCallback({\r\n            state,\r\n            action,\r\n            matchID,\r\n        });\r\n        if (this.game.deltaState) {\r\n            this.transportAPI.sendAll({\r\n                type: 'patch',\r\n                args: [matchID, stateID, prevState, state],\r\n            });\r\n        }\r\n        else {\r\n            this.transportAPI.sendAll({\r\n                type: 'update',\r\n                args: [matchID, state],\r\n            });\r\n        }\r\n        const { deltalog, ...stateWithoutDeltalog } = state;\r\n        let newMetadata;\r\n        if (metadata &&\r\n            (metadata.gameover === undefined || metadata.gameover === null)) {\r\n            newMetadata = {\r\n                ...metadata,\r\n                updatedAt: Date.now(),\r\n            };\r\n            if (state.ctx.gameover !== undefined) {\r\n                newMetadata.gameover = state.ctx.gameover;\r\n            }\r\n        }\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\r\n            if (newMetadata)\r\n                this.storageAPI.setMetadata(key, newMetadata);\r\n        }\r\n        else {\r\n            const writes = [\r\n                this.storageAPI.setState(key, stateWithoutDeltalog, deltalog),\r\n            ];\r\n            if (newMetadata) {\r\n                writes.push(this.storageAPI.setMetadata(key, newMetadata));\r\n            }\r\n            await Promise.all(writes);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the client connects / reconnects.\r\n     * Returns the latest game state and the entire log.\r\n     */\r\n    async onSync(matchID, playerID, credentials, numPlayers = 2) {\r\n        const key = matchID;\r\n        const fetchOpts = {\r\n            state: true,\r\n            metadata: true,\r\n            log: true,\r\n            initialState: true,\r\n        };\r\n        const fetchResult = isSynchronous(this.storageAPI)\r\n            ? this.storageAPI.fetch(key, fetchOpts)\r\n            : await this.storageAPI.fetch(key, fetchOpts);\r\n        let { state, initialState, log, metadata } = fetchResult;\r\n        if (this.auth && playerID !== undefined && playerID !== null) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        // If the game doesn't exist, then create one on demand.\r\n        // TODO: Move this out of the sync call.\r\n        if (state === undefined) {\r\n            const match = createMatch({\r\n                game: this.game,\r\n                unlisted: true,\r\n                numPlayers,\r\n                setupData: undefined,\r\n            });\r\n            if ('setupDataError' in match) {\r\n                return { error: 'game requires setupData' };\r\n            }\r\n            initialState = state = match.initialState;\r\n            metadata = match.metadata;\r\n            this.subscribeCallback({ state, matchID });\r\n            if (isSynchronous(this.storageAPI)) {\r\n                this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n            else {\r\n                await this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n        }\r\n        const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\r\n        const syncInfo = {\r\n            state,\r\n            log,\r\n            filteredMetadata,\r\n            initialState,\r\n        };\r\n        this.transportAPI.send({\r\n            playerID,\r\n            type: 'sync',\r\n            args: [matchID, syncInfo],\r\n        });\r\n        return;\r\n    }\r\n    /**\r\n     * Called when a client connects or disconnects.\r\n     * Updates and sends out metadata to reflect the player’s connection status.\r\n     */\r\n    async onConnectionChange(matchID, playerID, credentials, connected) {\r\n        const key = matchID;\r\n        // Ignore changes for clients without a playerID, e.g. spectators.\r\n        if (playerID === undefined || playerID === null) {\r\n            return;\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        if (metadata === undefined) {\r\n            error(`metadata not found for matchID=[${key}]`);\r\n            return { error: 'metadata not found' };\r\n        }\r\n        if (metadata.players[playerID] === undefined) {\r\n            error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\r\n            return { error: 'player not in the match' };\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        metadata.players[playerID].isConnected = connected;\r\n        const filteredMetadata = filterMatchData(metadata);\r\n        this.transportAPI.sendAll({\r\n            type: 'matchData',\r\n            args: [matchID, filteredMetadata],\r\n        });\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n        else {\r\n            await this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n    }\r\n    async onChatMessage(matchID, chatMessage, credentials) {\r\n        const key = matchID;\r\n        if (this.auth) {\r\n            const { metadata } = await this.storageAPI.fetch(key, {\r\n                metadata: true,\r\n            });\r\n            if (!(chatMessage && typeof chatMessage.sender === 'string')) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID: chatMessage.sender,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        this.transportAPI.sendAll({\r\n            type: 'chat',\r\n            args: [matchID, chatMessage],\r\n        });\r\n    }\r\n}\n\nexport { Master as M };\n", "import { x as PlayerView } from './turn-order-8cc4909b.js';\nimport { createPatch } from 'rfc6902';\n\nconst applyPlayerView = (game, playerID, state) => ({\r\n    ...state,\r\n    G: game.playerView({ G: state.G, ctx: state.ctx, playerID }),\r\n    plugins: PlayerView(state, { playerID, game }),\r\n    deltalog: undefined,\r\n    _undo: [],\r\n    _redo: [],\r\n});\r\n/** Gets a function that filters the TransportData for a given player and game. */\r\nconst getFilterPlayerView = (game) => (playerID, payload) => {\r\n    switch (payload.type) {\r\n        case 'patch': {\r\n            const [matchID, stateID, prevState, state] = payload.args;\r\n            const log = redactLog(state.deltalog, playerID);\r\n            const filteredState = applyPlayerView(game, playerID, state);\r\n            const newStateID = state._stateID;\r\n            const prevFilteredState = applyPlayerView(game, playerID, prevState);\r\n            const patch = createPatch(prevFilteredState, filteredState);\r\n            return {\r\n                type: 'patch',\r\n                args: [matchID, stateID, newStateID, patch, log],\r\n            };\r\n        }\r\n        case 'update': {\r\n            const [matchID, state] = payload.args;\r\n            const log = redactLog(state.deltalog, playerID);\r\n            const filteredState = applyPlayerView(game, playerID, state);\r\n            return {\r\n                type: 'update',\r\n                args: [matchID, filteredState, log],\r\n            };\r\n        }\r\n        case 'sync': {\r\n            const [matchID, syncInfo] = payload.args;\r\n            const filteredState = applyPlayerView(game, playerID, syncInfo.state);\r\n            const log = redactLog(syncInfo.log, playerID);\r\n            const newSyncInfo = {\r\n                ...syncInfo,\r\n                state: filteredState,\r\n                log,\r\n            };\r\n            return {\r\n                type: 'sync',\r\n                args: [matchID, newSyncInfo],\r\n            };\r\n        }\r\n        default: {\r\n            return payload;\r\n        }\r\n    }\r\n};\r\n/**\r\n * Redact the log.\r\n *\r\n * @param {Array} log - The game log (or deltalog).\r\n * @param {String} playerID - The playerID that this log is\r\n *                            to be sent to.\r\n */\r\nfunction redactLog(log, playerID) {\r\n    if (log === undefined) {\r\n        return log;\r\n    }\r\n    return log.map((logEvent) => {\r\n        // filter for all other players and spectators.\r\n        if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {\r\n            return logEvent;\r\n        }\r\n        if (logEvent.redact !== true) {\r\n            return logEvent;\r\n        }\r\n        const payload = {\r\n            ...logEvent.action.payload,\r\n            args: null,\r\n        };\r\n        const filteredEvent = {\r\n            ...logEvent,\r\n            action: { ...logEvent.action, payload },\r\n        };\r\n        const { redact, ...remaining } = filteredEvent;\r\n        return remaining;\r\n    });\r\n}\n\nexport { getFilterPlayerView as g };\n", "import { T as Transport } from './transport-ce07b771.js';\nimport { S as Sync } from './util-991e76bb.js';\nimport { M as Master } from './master-17425f07.js';\nimport { g as getFilterPlayerView } from './filter-player-view-43ed49b0.js';\nimport ioNamespace__default from 'socket.io-client';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * InMemory data storage.\r\n */\r\nclass InMemory extends Sync {\r\n    /**\r\n     * Creates a new InMemory storage.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.state = new Map();\r\n        this.initial = new Map();\r\n        this.metadata = new Map();\r\n        this.log = new Map();\r\n    }\r\n    /**\r\n     * Create a new match.\r\n     *\r\n     * @override\r\n     */\r\n    createMatch(matchID, opts) {\r\n        this.initial.set(matchID, opts.initialState);\r\n        this.setState(matchID, opts.initialState);\r\n        this.setMetadata(matchID, opts.metadata);\r\n    }\r\n    /**\r\n     * Write the match metadata to the in-memory object.\r\n     */\r\n    setMetadata(matchID, metadata) {\r\n        this.metadata.set(matchID, metadata);\r\n    }\r\n    /**\r\n     * Write the match state to the in-memory object.\r\n     */\r\n    setState(matchID, state, deltalog) {\r\n        if (deltalog && deltalog.length > 0) {\r\n            const log = this.log.get(matchID) || [];\r\n            this.log.set(matchID, [...log, ...deltalog]);\r\n        }\r\n        this.state.set(matchID, state);\r\n    }\r\n    /**\r\n     * Fetches state for a particular matchID.\r\n     */\r\n    fetch(matchID, opts) {\r\n        const result = {};\r\n        if (opts.state) {\r\n            result.state = this.state.get(matchID);\r\n        }\r\n        if (opts.metadata) {\r\n            result.metadata = this.metadata.get(matchID);\r\n        }\r\n        if (opts.log) {\r\n            result.log = this.log.get(matchID) || [];\r\n        }\r\n        if (opts.initialState) {\r\n            result.initialState = this.initial.get(matchID);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Remove the match state from the in-memory object.\r\n     */\r\n    wipe(matchID) {\r\n        this.state.delete(matchID);\r\n        this.metadata.delete(matchID);\r\n    }\r\n    /**\r\n     * Return all keys.\r\n     *\r\n     * @override\r\n     */\r\n    listMatches(opts) {\r\n        return [...this.metadata.entries()]\r\n            .filter(([, metadata]) => {\r\n            if (!opts) {\r\n                return true;\r\n            }\r\n            if (opts.gameName !== undefined &&\r\n                metadata.gameName !== opts.gameName) {\r\n                return false;\r\n            }\r\n            if (opts.where !== undefined) {\r\n                if (opts.where.isGameover !== undefined) {\r\n                    const isGameover = metadata.gameover !== undefined;\r\n                    if (isGameover !== opts.where.isGameover) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (opts.where.updatedBefore !== undefined &&\r\n                    metadata.updatedAt >= opts.where.updatedBefore) {\r\n                    return false;\r\n                }\r\n                if (opts.where.updatedAfter !== undefined &&\r\n                    metadata.updatedAt <= opts.where.updatedAfter) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        })\r\n            .map(([key]) => key);\r\n    }\r\n}\n\nclass WithLocalStorageMap extends Map {\r\n    constructor(key) {\r\n        super();\r\n        this.key = key;\r\n        const cache = JSON.parse(localStorage.getItem(this.key)) || [];\r\n        cache.forEach((entry) => this.set(...entry));\r\n    }\r\n    sync() {\r\n        const entries = [...this.entries()];\r\n        localStorage.setItem(this.key, JSON.stringify(entries));\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value);\r\n        this.sync();\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        const result = super.delete(key);\r\n        this.sync();\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * locaStorage data storage.\r\n */\r\nclass LocalStorage extends InMemory {\r\n    constructor(storagePrefix = 'bgio') {\r\n        super();\r\n        const StorageMap = (stateKey) => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);\r\n        this.state = StorageMap('state');\r\n        this.initial = StorageMap('initial');\r\n        this.metadata = StorageMap('metadata');\r\n        this.log = StorageMap('log');\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Returns null if it is not a bot's turn.\r\n * Otherwise, returns a playerID of a bot that may play now.\r\n */\r\nfunction GetBotPlayer(state, bots) {\r\n    if (state.ctx.gameover !== undefined) {\r\n        return null;\r\n    }\r\n    if (state.ctx.activePlayers) {\r\n        for (const key of Object.keys(bots)) {\r\n            if (key in state.ctx.activePlayers) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n    else if (state.ctx.currentPlayer in bots) {\r\n        return state.ctx.currentPlayer;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Creates a local version of the master that the client\r\n * can interact with.\r\n */\r\nclass LocalMaster extends Master {\r\n    constructor({ game, bots, storageKey, persist }) {\r\n        const clientCallbacks = {};\r\n        const initializedBots = {};\r\n        if (game && game.ai && bots) {\r\n            for (const playerID in bots) {\r\n                const bot = bots[playerID];\r\n                initializedBots[playerID] = new bot({\r\n                    game,\r\n                    enumerate: game.ai.enumerate,\r\n                    seed: game.seed,\r\n                });\r\n            }\r\n        }\r\n        const send = ({ playerID, ...data }) => {\r\n            const callback = clientCallbacks[playerID];\r\n            if (callback !== undefined) {\r\n                callback(filterPlayerView(playerID, data));\r\n            }\r\n        };\r\n        const filterPlayerView = getFilterPlayerView(game);\r\n        const transportAPI = {\r\n            send,\r\n            sendAll: (payload) => {\r\n                for (const playerID in clientCallbacks) {\r\n                    send({ playerID, ...payload });\r\n                }\r\n            },\r\n        };\r\n        const storage = persist ? new LocalStorage(storageKey) : new InMemory();\r\n        super(game, storage, transportAPI);\r\n        this.connect = (playerID, callback) => {\r\n            clientCallbacks[playerID] = callback;\r\n        };\r\n        this.subscribe(({ state, matchID }) => {\r\n            if (!bots) {\r\n                return;\r\n            }\r\n            const botPlayer = GetBotPlayer(state, initializedBots);\r\n            if (botPlayer !== null) {\r\n                setTimeout(async () => {\r\n                    const botAction = await initializedBots[botPlayer].play(state, botPlayer);\r\n                    await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);\r\n                }, 100);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Local\r\n *\r\n * Transport interface that embeds a GameMaster within it\r\n * that you can connect multiple clients to.\r\n */\r\nclass LocalTransport extends Transport {\r\n    /**\r\n     * Creates a new Mutiplayer instance.\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     */\r\n    constructor({ master, ...opts }) {\r\n        super(opts);\r\n        this.master = master;\r\n    }\r\n    sendChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.master.onChatMessage(...args);\r\n    }\r\n    sendAction(state, action) {\r\n        this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);\r\n    }\r\n    requestSync() {\r\n        this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);\r\n    }\r\n    connect() {\r\n        this.setConnectionStatus(true);\r\n        this.master.connect(this.playerID, (data) => this.notifyClient(data));\r\n        this.requestSync();\r\n    }\r\n    disconnect() {\r\n        this.setConnectionStatus(false);\r\n    }\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.connect();\r\n    }\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.connect();\r\n    }\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.connect();\r\n    }\r\n}\r\n/**\r\n * Global map storing local master instances.\r\n */\r\nconst localMasters = new Map();\r\n/**\r\n * Create a local transport.\r\n */\r\nfunction Local({ bots, persist, storageKey } = {}) {\r\n    return (transportOpts) => {\r\n        const { gameKey, game } = transportOpts;\r\n        let master;\r\n        const instance = localMasters.get(gameKey);\r\n        if (instance &&\r\n            instance.bots === bots &&\r\n            instance.storageKey === storageKey &&\r\n            instance.persist === persist) {\r\n            master = instance.master;\r\n        }\r\n        if (!master) {\r\n            master = new LocalMaster({ game, bots, persist, storageKey });\r\n            localMasters.set(gameKey, { master, bots, persist, storageKey });\r\n        }\r\n        return new LocalTransport({ master, ...transportOpts });\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst io = ioNamespace__default;\r\n/**\r\n * SocketIO\r\n *\r\n * Transport interface that interacts with the Master via socket.io.\r\n */\r\nclass SocketIOTransport extends Transport {\r\n    /**\r\n     * Creates a new Multiplayer instance.\r\n     * @param {object} socket - Override for unit tests.\r\n     * @param {object} socketOpts - Options to pass to socket.io.\r\n     * @param {object} store - Redux store\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} credentials - Authentication credentials\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\r\n     */\r\n    constructor({ socket, socketOpts, server, ...opts }) {\r\n        super(opts);\r\n        this.server = server;\r\n        this.socket = socket;\r\n        this.socketOpts = socketOpts;\r\n    }\r\n    sendAction(state, action) {\r\n        const args = [\r\n            action,\r\n            state._stateID,\r\n            this.matchID,\r\n            this.playerID,\r\n        ];\r\n        this.socket.emit('update', ...args);\r\n    }\r\n    sendChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.socket.emit('chat', ...args);\r\n    }\r\n    connect() {\r\n        if (!this.socket) {\r\n            if (this.server) {\r\n                let server = this.server;\r\n                if (server.search(/^https?:\\/\\//) == -1) {\r\n                    server = 'http://' + this.server;\r\n                }\r\n                if (server.slice(-1) != '/') {\r\n                    // add trailing slash if not already present\r\n                    server = server + '/';\r\n                }\r\n                this.socket = io(server + this.gameName, this.socketOpts);\r\n            }\r\n            else {\r\n                this.socket = io('/' + this.gameName, this.socketOpts);\r\n            }\r\n        }\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update as a patch to other clients (including\r\n        // this one).\r\n        this.socket.on('patch', (matchID, prevStateID, stateID, patch, deltalog) => {\r\n            this.notifyClient({\r\n                type: 'patch',\r\n                args: [matchID, prevStateID, stateID, patch, deltalog],\r\n            });\r\n        });\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update to other clients (including\r\n        // this one).\r\n        this.socket.on('update', (matchID, state, deltalog) => {\r\n            this.notifyClient({\r\n                type: 'update',\r\n                args: [matchID, state, deltalog],\r\n            });\r\n        });\r\n        // Called when the client first connects to the master\r\n        // and requests the current game state.\r\n        this.socket.on('sync', (matchID, syncInfo) => {\r\n            this.notifyClient({ type: 'sync', args: [matchID, syncInfo] });\r\n        });\r\n        // Called when new player joins the match or changes\r\n        // it's connection status\r\n        this.socket.on('matchData', (matchID, matchData) => {\r\n            this.notifyClient({ type: 'matchData', args: [matchID, matchData] });\r\n        });\r\n        this.socket.on('chat', (matchID, chatMessage) => {\r\n            this.notifyClient({ type: 'chat', args: [matchID, chatMessage] });\r\n        });\r\n        // Keep track of connection status.\r\n        this.socket.on('connect', () => {\r\n            // Initial sync to get game state.\r\n            this.requestSync();\r\n            this.setConnectionStatus(true);\r\n        });\r\n        this.socket.on('disconnect', () => {\r\n            this.setConnectionStatus(false);\r\n        });\r\n    }\r\n    disconnect() {\r\n        this.socket.close();\r\n        this.socket = null;\r\n        this.setConnectionStatus(false);\r\n    }\r\n    requestSync() {\r\n        if (this.socket) {\r\n            const args = [\r\n                this.matchID,\r\n                this.playerID,\r\n                this.credentials,\r\n                this.numPlayers,\r\n            ];\r\n            this.socket.emit('sync', ...args);\r\n        }\r\n    }\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.requestSync();\r\n    }\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.requestSync();\r\n    }\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.requestSync();\r\n    }\r\n}\r\nfunction SocketIO({ server, socketOpts } = {}) {\r\n    return (transportOpts) => new SocketIOTransport({\r\n        server,\r\n        socketOpts,\r\n        ...transportOpts,\r\n    });\r\n}\n\nexport { Local as L, SocketIO as S };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAI;AAAA,CACH,SAAUA,OAAM;AACb,EAAAA,MAAKA,MAAK,MAAM,IAAI,CAAC,IAAI;AACzB,EAAAA,MAAKA,MAAK,OAAO,IAAI,CAAC,IAAI;AAC9B,GAAG,SAAS,OAAO,CAAC,EAAE;AAItB,SAAS,cAAc,YAAY;AAC/B,SAAO,WAAW,KAAK,MAAM,KAAK;AACtC;AA0CA,IAAM,OAAN,MAAW;AAAA,EACP,OAAO;AACH,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACN;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,YAAY,SAAS,MAAM;AACvB,QAAI,KAAK,YAAY;AACjB,cAAQ,KAAK,mEAAmE,mDAAmD;AACnI,aAAO,KAAK,WAAW,SAAS,IAAI;AAAA,IACxC,OACK;AACD,cAAQ,MAAM,iEAAiE;AAAA,IACnF;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,MAAM;AACd,QAAI,KAAK,WAAW;AAChB,cAAQ,KAAK,mEAAmE,kDAAkD;AAClI,aAAO,KAAK,UAAU,IAAI;AAAA,IAC9B,OACK;AACD,cAAQ,MAAM,iEAAiE;AAAA,IACnF;AAAA,EACJ;AACJ;AAKA,IAAM,iBAAiB,CAAC,EAAE,MAAM,UAAU,WAAW,WAAY,MAAM;AACnE,QAAM,WAAW;AAAA,IACb,UAAU,KAAK;AAAA,IACf,UAAU,CAAC,CAAC;AAAA,IACZ,SAAS,CAAC;AAAA,IACV,WAAW,KAAK,IAAI;AAAA,IACpB,WAAW,KAAK,IAAI;AAAA,EACxB;AACA,MAAI,cAAc;AACd,aAAS,YAAY;AACzB,WAAS,cAAc,GAAG,cAAc,YAAY,eAAe;AAC/D,aAAS,QAAQ,WAAW,IAAI,EAAE,IAAI,YAAY;AAAA,EACtD;AACA,SAAO;AACX;AAMA,IAAM,cAAc,CAAC,EAAE,MAAM,YAAY,WAAW,SAAU,MAAM;AAChE,MAAI,CAAC,cAAc,OAAO,eAAe;AACrC,iBAAa;AACjB,QAAM,iBAAiB,KAAK,qBAAqB,KAAK,kBAAkB,WAAW,UAAU;AAC7F,MAAI,mBAAmB;AACnB,WAAO,EAAE,eAAe;AAC5B,QAAM,WAAW,eAAe,EAAE,MAAM,YAAY,WAAW,SAAS,CAAC;AACzE,QAAM,eAAe,eAAe,EAAE,MAAM,YAAY,UAAU,CAAC;AACnE,SAAO,EAAE,UAAU,aAAa;AACpC;;;ACrHA,IAAM,kBAAkB,CAAC,cAAc,OAAO,OAAO,UAAU,OAAO,EAAE,IAAI,CAAC,WAAW;AACpF,QAAM,EAAE,aAAa,GAAG,aAAa,IAAI;AACzC,SAAO;AACX,CAAC;AAID,IAAM,6BAA6B,CAAC,WAAW;AAC3C,QAAM,EAAE,aAAa,GAAG,QAAQ,IAAI,OAAO;AAC3C,SAAO,EAAE,GAAG,QAAQ,QAAQ;AAChC;AAQA,IAAM,SAAN,MAAa;AAAA,EACT,YAAY,MAAM,YAAY,cAAc,MAAM;AAC9C,SAAK,OAAO,kBAAkB,IAAI;AAClC,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,oBAAoB,MAAM;AAAA,IAAE;AACjC,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,UAAU,IAAI;AACV,SAAK,oBAAoB;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,SAAS,YAAY,SAAS,SAAS,UAAU;AACnD,QAAI,CAAC,cAAc,CAAC,WAAW,SAAS;AACpC,aAAO,EAAE,OAAO,mCAAmC;AAAA,IACvD;AACA,QAAI;AACJ,QAAI,cAAc,KAAK,UAAU,GAAG;AAChC,OAAC,EAAE,SAAS,IAAI,KAAK,WAAW,MAAM,SAAS,EAAE,UAAU,KAAK,CAAC;AAAA,IACrE,OACK;AACD,OAAC,EAAE,SAAS,IAAI,MAAM,KAAK,WAAW,MAAM,SAAS,EAAE,UAAU,KAAK,CAAC;AAAA,IAC3E;AACA,QAAI,KAAK,MAAM;AACX,YAAM,cAAc,MAAM,KAAK,KAAK,wBAAwB;AAAA,QACxD;AAAA,QACA,aAAa,WAAW,QAAQ;AAAA,QAChC;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,aAAa;AACd,eAAO,EAAE,OAAO,sBAAsB;AAAA,MAC1C;AAAA,IACJ;AACA,UAAM,SAAS,2BAA2B,UAAU;AACpD,UAAM,MAAM;AACZ,QAAI;AACJ,QAAI,cAAc,KAAK,UAAU,GAAG;AAChC,OAAC,EAAE,MAAM,IAAI,KAAK,WAAW,MAAM,KAAK,EAAE,OAAO,KAAK,CAAC;AAAA,IAC3D,OACK;AACD,OAAC,EAAE,MAAM,IAAI,MAAM,KAAK,WAAW,MAAM,KAAK,EAAE,OAAO,KAAK,CAAC;AAAA,IACjE;AACA,QAAI,UAAU,QAAW;AACrB,YAAM,4BAA4B,GAAG,GAAG;AACxC,aAAO,EAAE,OAAO,iBAAiB;AAAA,IACrC;AACA,QAAI,MAAM,IAAI,aAAa,QAAW;AAClC,YAAM,wBAAwB,GAAG,iBAAiB,QAAQ,cACzC,OAAO,QAAQ,IAAI,GAAG;AACvC;AAAA,IACJ;AACA,UAAM,UAAU,kBAAkB;AAAA,MAC9B,MAAM,KAAK;AAAA,IACf,CAAC;AACD,UAAM,aAAa,gBAAgB,2BAA2B;AAC9D,UAAM,QAAQ,YAAY,SAAS,OAAO,UAAU;AAIpD,QAAI,OAAO,QAAQ,QAAQ,OAAO,QAAQ,MAAM;AAC5C,YAAM,mBAAmB,MAAM,IAAI,kBAAkB;AACrD,YAAM,kBAAkB,MAAM,IAAI,kBAAkB;AACpD;AAAA;AAAA,QAEC,CAAC,oBAAoB,CAAC;AAAA,QAElB,qBACI,MAAM,IAAI,cAAc,QAAQ,MAAM,UACnC,OAAO,KAAK,MAAM,IAAI,aAAa,EAAE,SAAS;AAAA,QAAK;AAC3D,cAAM,aAAa,QAAQ,gCAAgC;AAC3D;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,CAAC,KAAK,KAAK,KAAK,eAAe,MAAM,GAAG,MAAM,KAAK,QAAQ,GAAG;AAC9D,YAAM,iCAAiC,QAAQ,cAC9B,OAAO,QAAQ,IAAI,GAAG;AACvC;AAAA,IACJ;AAEA,UAAM,OAAO,OAAO,QAAQ,YACtB,KAAK,KAAK,KAAK,QAAQ,MAAM,KAAK,OAAO,QAAQ,MAAM,QAAQ,IAC/D;AAEN,QAAI,OAAO,QAAQ,aAAa,CAAC,MAAM;AACnC,YAAM,4DAA4D,QAAQ,cACzD,OAAO,QAAQ,IAAI,GAAG;AACvC;AAAA,IACJ;AAGA,QAAI,MAAM,aAAa,WACnB,EAAE,QAAQ,eAAe,IAAI,KAAK,KAAK,qBAAqB;AAC5D,YAAM,yBAAyB,OAAO,gBAAgB,MAAM,QAAQ,iBAChD,QAAQ,cAAc,OAAO,QAAQ,IAAI,GAAG;AAChE;AAAA,IACJ;AACA,UAAM,YAAY,MAAM,SAAS;AAEjC,UAAM,SAAS,MAAM;AACrB,YAAQ,MAAM,SAAS;AACvB,SAAK,kBAAkB;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACJ,CAAC;AACD,QAAI,KAAK,KAAK,YAAY;AACtB,WAAK,aAAa,QAAQ;AAAA,QACtB,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,SAAS,WAAW,KAAK;AAAA,MAC7C,CAAC;AAAA,IACL,OACK;AACD,WAAK,aAAa,QAAQ;AAAA,QACtB,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,KAAK;AAAA,MACzB,CAAC;AAAA,IACL;AACA,UAAM,EAAE,UAAU,GAAG,qBAAqB,IAAI;AAC9C,QAAI;AACJ,QAAI,aACC,SAAS,aAAa,UAAa,SAAS,aAAa,OAAO;AACjE,oBAAc;AAAA,QACV,GAAG;AAAA,QACH,WAAW,KAAK,IAAI;AAAA,MACxB;AACA,UAAI,MAAM,IAAI,aAAa,QAAW;AAClC,oBAAY,WAAW,MAAM,IAAI;AAAA,MACrC;AAAA,IACJ;AACA,QAAI,cAAc,KAAK,UAAU,GAAG;AAChC,WAAK,WAAW,SAAS,KAAK,sBAAsB,QAAQ;AAC5D,UAAI;AACA,aAAK,WAAW,YAAY,KAAK,WAAW;AAAA,IACpD,OACK;AACD,YAAM,SAAS;AAAA,QACX,KAAK,WAAW,SAAS,KAAK,sBAAsB,QAAQ;AAAA,MAChE;AACA,UAAI,aAAa;AACb,eAAO,KAAK,KAAK,WAAW,YAAY,KAAK,WAAW,CAAC;AAAA,MAC7D;AACA,YAAM,QAAQ,IAAI,MAAM;AAAA,IAC5B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,SAAS,UAAU,aAAa,aAAa,GAAG;AACzD,UAAM,MAAM;AACZ,UAAM,YAAY;AAAA,MACd,OAAO;AAAA,MACP,UAAU;AAAA,MACV,KAAK;AAAA,MACL,cAAc;AAAA,IAClB;AACA,UAAM,cAAc,cAAc,KAAK,UAAU,IAC3C,KAAK,WAAW,MAAM,KAAK,SAAS,IACpC,MAAM,KAAK,WAAW,MAAM,KAAK,SAAS;AAChD,QAAI,EAAE,OAAO,cAAc,KAAK,SAAS,IAAI;AAC7C,QAAI,KAAK,QAAQ,aAAa,UAAa,aAAa,MAAM;AAC1D,YAAM,cAAc,MAAM,KAAK,KAAK,wBAAwB;AAAA,QACxD;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,aAAa;AACd,eAAO,EAAE,OAAO,eAAe;AAAA,MACnC;AAAA,IACJ;AAGA,QAAI,UAAU,QAAW;AACrB,YAAM,QAAQ,YAAY;AAAA,QACtB,MAAM,KAAK;AAAA,QACX,UAAU;AAAA,QACV;AAAA,QACA,WAAW;AAAA,MACf,CAAC;AACD,UAAI,oBAAoB,OAAO;AAC3B,eAAO,EAAE,OAAO,0BAA0B;AAAA,MAC9C;AACA,qBAAe,QAAQ,MAAM;AAC7B,iBAAW,MAAM;AACjB,WAAK,kBAAkB,EAAE,OAAO,QAAQ,CAAC;AACzC,UAAI,cAAc,KAAK,UAAU,GAAG;AAChC,aAAK,WAAW,YAAY,KAAK,EAAE,cAAc,SAAS,CAAC;AAAA,MAC/D,OACK;AACD,cAAM,KAAK,WAAW,YAAY,KAAK,EAAE,cAAc,SAAS,CAAC;AAAA,MACrE;AAAA,IACJ;AACA,UAAM,mBAAmB,WAAW,gBAAgB,QAAQ,IAAI;AAChE,UAAM,WAAW;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AACA,SAAK,aAAa,KAAK;AAAA,MACnB;AAAA,MACA,MAAM;AAAA,MACN,MAAM,CAAC,SAAS,QAAQ;AAAA,IAC5B,CAAC;AACD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,SAAS,UAAU,aAAa,WAAW;AAChE,UAAM,MAAM;AAEZ,QAAI,aAAa,UAAa,aAAa,MAAM;AAC7C;AAAA,IACJ;AACA,QAAI;AACJ,QAAI,cAAc,KAAK,UAAU,GAAG;AAChC,OAAC,EAAE,SAAS,IAAI,KAAK,WAAW,MAAM,KAAK,EAAE,UAAU,KAAK,CAAC;AAAA,IACjE,OACK;AACD,OAAC,EAAE,SAAS,IAAI,MAAM,KAAK,WAAW,MAAM,KAAK,EAAE,UAAU,KAAK,CAAC;AAAA,IACvE;AACA,QAAI,aAAa,QAAW;AACxB,YAAM,mCAAmC,GAAG,GAAG;AAC/C,aAAO,EAAE,OAAO,qBAAqB;AAAA,IACzC;AACA,QAAI,SAAS,QAAQ,QAAQ,MAAM,QAAW;AAC1C,YAAM,qCAAqC,GAAG,eAAe,QAAQ,GAAG;AACxE,aAAO,EAAE,OAAO,0BAA0B;AAAA,IAC9C;AACA,QAAI,KAAK,MAAM;AACX,YAAM,cAAc,MAAM,KAAK,KAAK,wBAAwB;AAAA,QACxD;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,aAAa;AACd,eAAO,EAAE,OAAO,eAAe;AAAA,MACnC;AAAA,IACJ;AACA,aAAS,QAAQ,QAAQ,EAAE,cAAc;AACzC,UAAM,mBAAmB,gBAAgB,QAAQ;AACjD,SAAK,aAAa,QAAQ;AAAA,MACtB,MAAM;AAAA,MACN,MAAM,CAAC,SAAS,gBAAgB;AAAA,IACpC,CAAC;AACD,QAAI,cAAc,KAAK,UAAU,GAAG;AAChC,WAAK,WAAW,YAAY,KAAK,QAAQ;AAAA,IAC7C,OACK;AACD,YAAM,KAAK,WAAW,YAAY,KAAK,QAAQ;AAAA,IACnD;AAAA,EACJ;AAAA,EACA,MAAM,cAAc,SAAS,aAAa,aAAa;AACnD,UAAM,MAAM;AACZ,QAAI,KAAK,MAAM;AACX,YAAM,EAAE,SAAS,IAAI,MAAM,KAAK,WAAW,MAAM,KAAK;AAAA,QAClD,UAAU;AAAA,MACd,CAAC;AACD,UAAI,EAAE,eAAe,OAAO,YAAY,WAAW,WAAW;AAC1D,eAAO,EAAE,OAAO,eAAe;AAAA,MACnC;AACA,YAAM,cAAc,MAAM,KAAK,KAAK,wBAAwB;AAAA,QACxD,UAAU,YAAY;AAAA,QACtB;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,aAAa;AACd,eAAO,EAAE,OAAO,eAAe;AAAA,MACnC;AAAA,IACJ;AACA,SAAK,aAAa,QAAQ;AAAA,MACtB,MAAM;AAAA,MACN,MAAM,CAAC,SAAS,WAAW;AAAA,IAC/B,CAAC;AAAA,EACL;AACJ;;;AC1TA,qBAA4B;AAE5B,IAAM,kBAAkB,CAAC,MAAM,UAAU,WAAW;AAAA,EAChD,GAAG;AAAA,EACH,GAAG,KAAK,WAAW,EAAE,GAAG,MAAM,GAAG,KAAK,MAAM,KAAK,SAAS,CAAC;AAAA,EAC3D,SAAS,WAAW,OAAO,EAAE,UAAU,KAAK,CAAC;AAAA,EAC7C,UAAU;AAAA,EACV,OAAO,CAAC;AAAA,EACR,OAAO,CAAC;AACZ;AAEA,IAAM,sBAAsB,CAAC,SAAS,CAAC,UAAU,YAAY;AACzD,UAAQ,QAAQ,MAAM;AAAA,IAClB,KAAK,SAAS;AACV,YAAM,CAAC,SAAS,SAAS,WAAW,KAAK,IAAI,QAAQ;AACrD,YAAM,MAAM,UAAU,MAAM,UAAU,QAAQ;AAC9C,YAAM,gBAAgB,gBAAgB,MAAM,UAAU,KAAK;AAC3D,YAAM,aAAa,MAAM;AACzB,YAAM,oBAAoB,gBAAgB,MAAM,UAAU,SAAS;AACnE,YAAM,YAAQ,4BAAY,mBAAmB,aAAa;AAC1D,aAAO;AAAA,QACH,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,SAAS,YAAY,OAAO,GAAG;AAAA,MACnD;AAAA,IACJ;AAAA,IACA,KAAK,UAAU;AACX,YAAM,CAAC,SAAS,KAAK,IAAI,QAAQ;AACjC,YAAM,MAAM,UAAU,MAAM,UAAU,QAAQ;AAC9C,YAAM,gBAAgB,gBAAgB,MAAM,UAAU,KAAK;AAC3D,aAAO;AAAA,QACH,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,eAAe,GAAG;AAAA,MACtC;AAAA,IACJ;AAAA,IACA,KAAK,QAAQ;AACT,YAAM,CAAC,SAAS,QAAQ,IAAI,QAAQ;AACpC,YAAM,gBAAgB,gBAAgB,MAAM,UAAU,SAAS,KAAK;AACpE,YAAM,MAAM,UAAU,SAAS,KAAK,QAAQ;AAC5C,YAAM,cAAc;AAAA,QAChB,GAAG;AAAA,QACH,OAAO;AAAA,QACP;AAAA,MACJ;AACA,aAAO;AAAA,QACH,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,WAAW;AAAA,MAC/B;AAAA,IACJ;AAAA,IACA,SAAS;AACL,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAQA,SAAS,UAAU,KAAK,UAAU;AAC9B,MAAI,QAAQ,QAAW;AACnB,WAAO;AAAA,EACX;AACA,SAAO,IAAI,IAAI,CAAC,aAAa;AAEzB,QAAI,aAAa,QAAQ,CAAC,aAAa,CAAC,SAAS,OAAO,QAAQ,UAAU;AACtE,aAAO;AAAA,IACX;AACA,QAAI,SAAS,WAAW,MAAM;AAC1B,aAAO;AAAA,IACX;AACA,UAAM,UAAU;AAAA,MACZ,GAAG,SAAS,OAAO;AAAA,MACnB,MAAM;AAAA,IACV;AACA,UAAM,gBAAgB;AAAA,MAClB,GAAG;AAAA,MACH,QAAQ,EAAE,GAAG,SAAS,QAAQ,QAAQ;AAAA,IAC1C;AACA,UAAM,EAAE,QAAQ,GAAG,UAAU,IAAI;AACjC,WAAO;AAAA,EACX,CAAC;AACL;;;ACpEA,IAAM,WAAN,cAAuB,KAAK;AAAA;AAAA;AAAA;AAAA,EAIxB,cAAc;AACV,UAAM;AACN,SAAK,QAAQ,oBAAI,IAAI;AACrB,SAAK,UAAU,oBAAI,IAAI;AACvB,SAAK,WAAW,oBAAI,IAAI;AACxB,SAAK,MAAM,oBAAI,IAAI;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,SAAS,MAAM;AACvB,SAAK,QAAQ,IAAI,SAAS,KAAK,YAAY;AAC3C,SAAK,SAAS,SAAS,KAAK,YAAY;AACxC,SAAK,YAAY,SAAS,KAAK,QAAQ;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,SAAS,UAAU;AAC3B,SAAK,SAAS,IAAI,SAAS,QAAQ;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,SAAS,OAAO,UAAU;AAC/B,QAAI,YAAY,SAAS,SAAS,GAAG;AACjC,YAAM,MAAM,KAAK,IAAI,IAAI,OAAO,KAAK,CAAC;AACtC,WAAK,IAAI,IAAI,SAAS,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC;AAAA,IAC/C;AACA,SAAK,MAAM,IAAI,SAAS,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS,MAAM;AACjB,UAAM,SAAS,CAAC;AAChB,QAAI,KAAK,OAAO;AACZ,aAAO,QAAQ,KAAK,MAAM,IAAI,OAAO;AAAA,IACzC;AACA,QAAI,KAAK,UAAU;AACf,aAAO,WAAW,KAAK,SAAS,IAAI,OAAO;AAAA,IAC/C;AACA,QAAI,KAAK,KAAK;AACV,aAAO,MAAM,KAAK,IAAI,IAAI,OAAO,KAAK,CAAC;AAAA,IAC3C;AACA,QAAI,KAAK,cAAc;AACnB,aAAO,eAAe,KAAK,QAAQ,IAAI,OAAO;AAAA,IAClD;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,KAAK,SAAS;AACV,SAAK,MAAM,OAAO,OAAO;AACzB,SAAK,SAAS,OAAO,OAAO;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,MAAM;AACd,WAAO,CAAC,GAAG,KAAK,SAAS,QAAQ,CAAC,EAC7B,OAAO,CAAC,CAAC,EAAE,QAAQ,MAAM;AAC1B,UAAI,CAAC,MAAM;AACP,eAAO;AAAA,MACX;AACA,UAAI,KAAK,aAAa,UAClB,SAAS,aAAa,KAAK,UAAU;AACrC,eAAO;AAAA,MACX;AACA,UAAI,KAAK,UAAU,QAAW;AAC1B,YAAI,KAAK,MAAM,eAAe,QAAW;AACrC,gBAAM,aAAa,SAAS,aAAa;AACzC,cAAI,eAAe,KAAK,MAAM,YAAY;AACtC,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,YAAI,KAAK,MAAM,kBAAkB,UAC7B,SAAS,aAAa,KAAK,MAAM,eAAe;AAChD,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,MAAM,iBAAiB,UAC5B,SAAS,aAAa,KAAK,MAAM,cAAc;AAC/C,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX,CAAC,EACI,IAAI,CAAC,CAAC,GAAG,MAAM,GAAG;AAAA,EAC3B;AACJ;AAEA,IAAM,sBAAN,cAAkC,IAAI;AAAA,EAClC,YAAY,KAAK;AACb,UAAM;AACN,SAAK,MAAM;AACX,UAAM,QAAQ,KAAK,MAAM,aAAa,QAAQ,KAAK,GAAG,CAAC,KAAK,CAAC;AAC7D,UAAM,QAAQ,CAAC,UAAU,KAAK,IAAI,GAAG,KAAK,CAAC;AAAA,EAC/C;AAAA,EACA,OAAO;AACH,UAAM,UAAU,CAAC,GAAG,KAAK,QAAQ,CAAC;AAClC,iBAAa,QAAQ,KAAK,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EAC1D;AAAA,EACA,IAAI,KAAK,OAAO;AACZ,UAAM,IAAI,KAAK,KAAK;AACpB,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AAAA,EACA,OAAO,KAAK;AACR,UAAM,SAAS,MAAM,OAAO,GAAG;AAC/B,SAAK,KAAK;AACV,WAAO;AAAA,EACX;AACJ;AAIA,IAAM,eAAN,cAA2B,SAAS;AAAA,EAChC,YAAY,gBAAgB,QAAQ;AAChC,UAAM;AACN,UAAM,aAAa,CAAC,aAAa,IAAI,oBAAoB,GAAG,aAAa,IAAI,QAAQ,EAAE;AACvF,SAAK,QAAQ,WAAW,OAAO;AAC/B,SAAK,UAAU,WAAW,SAAS;AACnC,SAAK,WAAW,WAAW,UAAU;AACrC,SAAK,MAAM,WAAW,KAAK;AAAA,EAC/B;AACJ;AAaA,SAAS,aAAa,OAAO,MAAM;AAC/B,MAAI,MAAM,IAAI,aAAa,QAAW;AAClC,WAAO;AAAA,EACX;AACA,MAAI,MAAM,IAAI,eAAe;AACzB,eAAW,OAAO,OAAO,KAAK,IAAI,GAAG;AACjC,UAAI,OAAO,MAAM,IAAI,eAAe;AAChC,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ,WACS,MAAM,IAAI,iBAAiB,MAAM;AACtC,WAAO,MAAM,IAAI;AAAA,EACrB;AACA,SAAO;AACX;AAKA,IAAM,cAAN,cAA0B,OAAO;AAAA,EAC7B,YAAY,EAAE,MAAM,MAAM,YAAY,QAAQ,GAAG;AAC7C,UAAM,kBAAkB,CAAC;AACzB,UAAM,kBAAkB,CAAC;AACzB,QAAI,QAAQ,KAAK,MAAM,MAAM;AACzB,iBAAW,YAAY,MAAM;AACzB,cAAM,MAAM,KAAK,QAAQ;AACzB,wBAAgB,QAAQ,IAAI,IAAI,IAAI;AAAA,UAChC;AAAA,UACA,WAAW,KAAK,GAAG;AAAA,UACnB,MAAM,KAAK;AAAA,QACf,CAAC;AAAA,MACL;AAAA,IACJ;AACA,UAAM,OAAO,CAAC,EAAE,UAAU,GAAG,KAAK,MAAM;AACpC,YAAM,WAAW,gBAAgB,QAAQ;AACzC,UAAI,aAAa,QAAW;AACxB,iBAAS,iBAAiB,UAAU,IAAI,CAAC;AAAA,MAC7C;AAAA,IACJ;AACA,UAAM,mBAAmB,oBAAoB,IAAI;AACjD,UAAM,eAAe;AAAA,MACjB;AAAA,MACA,SAAS,CAAC,YAAY;AAClB,mBAAW,YAAY,iBAAiB;AACpC,eAAK,EAAE,UAAU,GAAG,QAAQ,CAAC;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,UAAU,UAAU,IAAI,aAAa,UAAU,IAAI,IAAI,SAAS;AACtE,UAAM,MAAM,SAAS,YAAY;AACjC,SAAK,UAAU,CAAC,UAAU,aAAa;AACnC,sBAAgB,QAAQ,IAAI;AAAA,IAChC;AACA,SAAK,UAAU,CAAC,EAAE,OAAO,QAAQ,MAAM;AACnC,UAAI,CAAC,MAAM;AACP;AAAA,MACJ;AACA,YAAM,YAAY,aAAa,OAAO,eAAe;AACrD,UAAI,cAAc,MAAM;AACpB,mBAAW,YAAY;AACnB,gBAAM,YAAY,MAAM,gBAAgB,SAAS,EAAE,KAAK,OAAO,SAAS;AACxE,gBAAM,KAAK,SAAS,UAAU,QAAQ,MAAM,UAAU,SAAS,UAAU,OAAO,QAAQ,QAAQ;AAAA,QACpG,GAAG,GAAG;AAAA,MACV;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AAOA,IAAM,iBAAN,cAA6B,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnC,YAAY,EAAE,QAAQ,GAAG,KAAK,GAAG;AAC7B,UAAM,IAAI;AACV,SAAK,SAAS;AAAA,EAClB;AAAA,EACA,gBAAgB,SAAS,aAAa;AAClC,UAAM,OAAO;AAAA,MACT;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IACT;AACA,SAAK,OAAO,cAAc,GAAG,IAAI;AAAA,EACrC;AAAA,EACA,WAAW,OAAO,QAAQ;AACtB,SAAK,OAAO,SAAS,QAAQ,MAAM,UAAU,KAAK,SAAS,KAAK,QAAQ;AAAA,EAC5E;AAAA,EACA,cAAc;AACV,SAAK,OAAO,OAAO,KAAK,SAAS,KAAK,UAAU,KAAK,aAAa,KAAK,UAAU;AAAA,EACrF;AAAA,EACA,UAAU;AACN,SAAK,oBAAoB,IAAI;AAC7B,SAAK,OAAO,QAAQ,KAAK,UAAU,CAAC,SAAS,KAAK,aAAa,IAAI,CAAC;AACpE,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,aAAa;AACT,SAAK,oBAAoB,KAAK;AAAA,EAClC;AAAA,EACA,cAAc,IAAI;AACd,SAAK,UAAU;AACf,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,eAAe,IAAI;AACf,SAAK,WAAW;AAChB,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,kBAAkB,aAAa;AAC3B,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AACJ;AAIA,IAAM,eAAe,oBAAI,IAAI;AAI7B,SAAS,MAAM,EAAE,MAAM,SAAS,WAAW,IAAI,CAAC,GAAG;AAC/C,SAAO,CAAC,kBAAkB;AACtB,UAAM,EAAE,SAAS,KAAK,IAAI;AAC1B,QAAI;AACJ,UAAM,WAAW,aAAa,IAAI,OAAO;AACzC,QAAI,YACA,SAAS,SAAS,QAClB,SAAS,eAAe,cACxB,SAAS,YAAY,SAAS;AAC9B,eAAS,SAAS;AAAA,IACtB;AACA,QAAI,CAAC,QAAQ;AACT,eAAS,IAAI,YAAY,EAAE,MAAM,MAAM,SAAS,WAAW,CAAC;AAC5D,mBAAa,IAAI,SAAS,EAAE,QAAQ,MAAM,SAAS,WAAW,CAAC;AAAA,IACnE;AACA,WAAO,IAAI,eAAe,EAAE,QAAQ,GAAG,cAAc,CAAC;AAAA,EAC1D;AACJ;AASA,IAAM,KAAK;AAMX,IAAM,oBAAN,cAAgC,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAatC,YAAY,EAAE,QAAQ,YAAY,QAAQ,GAAG,KAAK,GAAG;AACjD,UAAM,IAAI;AACV,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,aAAa;AAAA,EACtB;AAAA,EACA,WAAW,OAAO,QAAQ;AACtB,UAAM,OAAO;AAAA,MACT;AAAA,MACA,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,IACT;AACA,SAAK,OAAO,KAAK,UAAU,GAAG,IAAI;AAAA,EACtC;AAAA,EACA,gBAAgB,SAAS,aAAa;AAClC,UAAM,OAAO;AAAA,MACT;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IACT;AACA,SAAK,OAAO,KAAK,QAAQ,GAAG,IAAI;AAAA,EACpC;AAAA,EACA,UAAU;AACN,QAAI,CAAC,KAAK,QAAQ;AACd,UAAI,KAAK,QAAQ;AACb,YAAI,SAAS,KAAK;AAClB,YAAI,OAAO,OAAO,cAAc,KAAK,IAAI;AACrC,mBAAS,YAAY,KAAK;AAAA,QAC9B;AACA,YAAI,OAAO,MAAM,EAAE,KAAK,KAAK;AAEzB,mBAAS,SAAS;AAAA,QACtB;AACA,aAAK,SAAS,GAAG,SAAS,KAAK,UAAU,KAAK,UAAU;AAAA,MAC5D,OACK;AACD,aAAK,SAAS,GAAG,MAAM,KAAK,UAAU,KAAK,UAAU;AAAA,MACzD;AAAA,IACJ;AAIA,SAAK,OAAO,GAAG,SAAS,CAAC,SAAS,aAAa,SAAS,OAAO,aAAa;AACxE,WAAK,aAAa;AAAA,QACd,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,aAAa,SAAS,OAAO,QAAQ;AAAA,MACzD,CAAC;AAAA,IACL,CAAC;AAID,SAAK,OAAO,GAAG,UAAU,CAAC,SAAS,OAAO,aAAa;AACnD,WAAK,aAAa;AAAA,QACd,MAAM;AAAA,QACN,MAAM,CAAC,SAAS,OAAO,QAAQ;AAAA,MACnC,CAAC;AAAA,IACL,CAAC;AAGD,SAAK,OAAO,GAAG,QAAQ,CAAC,SAAS,aAAa;AAC1C,WAAK,aAAa,EAAE,MAAM,QAAQ,MAAM,CAAC,SAAS,QAAQ,EAAE,CAAC;AAAA,IACjE,CAAC;AAGD,SAAK,OAAO,GAAG,aAAa,CAAC,SAAS,cAAc;AAChD,WAAK,aAAa,EAAE,MAAM,aAAa,MAAM,CAAC,SAAS,SAAS,EAAE,CAAC;AAAA,IACvE,CAAC;AACD,SAAK,OAAO,GAAG,QAAQ,CAAC,SAAS,gBAAgB;AAC7C,WAAK,aAAa,EAAE,MAAM,QAAQ,MAAM,CAAC,SAAS,WAAW,EAAE,CAAC;AAAA,IACpE,CAAC;AAED,SAAK,OAAO,GAAG,WAAW,MAAM;AAE5B,WAAK,YAAY;AACjB,WAAK,oBAAoB,IAAI;AAAA,IACjC,CAAC;AACD,SAAK,OAAO,GAAG,cAAc,MAAM;AAC/B,WAAK,oBAAoB,KAAK;AAAA,IAClC,CAAC;AAAA,EACL;AAAA,EACA,aAAa;AACT,SAAK,OAAO,MAAM;AAClB,SAAK,SAAS;AACd,SAAK,oBAAoB,KAAK;AAAA,EAClC;AAAA,EACA,cAAc;AACV,QAAI,KAAK,QAAQ;AACb,YAAM,OAAO;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACT;AACA,WAAK,OAAO,KAAK,QAAQ,GAAG,IAAI;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,cAAc,IAAI;AACd,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,eAAe,IAAI;AACf,SAAK,WAAW;AAChB,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,kBAAkB,aAAa;AAC3B,SAAK,cAAc;AACnB,SAAK,YAAY;AAAA,EACrB;AACJ;AACA,SAAS,SAAS,EAAE,QAAQ,WAAW,IAAI,CAAC,GAAG;AAC3C,SAAO,CAAC,kBAAkB,IAAI,kBAAkB;AAAA,IAC5C;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACP,CAAC;AACL;",
  "names": ["Type"]
}
